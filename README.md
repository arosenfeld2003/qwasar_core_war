## qwasar_core_war
# Core War!
Core War is a 1984 programming game in which two or more battle programs (called "warriors" or "champions") compete for control of a virtual computer. These programs are typically written in assembly language Redcode. The game was introduced in a Scientific American article by A.K. Dewdney.

Our version consists of programs that run in a virtual machine. Each program's objective is to execute a special instruction ("live"), given each program's task orientation. These programs simultaneously execute in the virtual machine in the same memory zone, which enables them to write on one another. It's coded in C-language and consists of three parts:

## Virtual Machine</br>
The sandbox environment where the programs will run.

## Assembler</br>
It's the core of syntax and rules in order to make a valid program. It takes in the champion code and converts to binary code executable by the Virtual Machine

## Programs</br>
The programs are the code representing the actions of the champions. They are written in a simplified assembly language specific to the virtual machine

### Virtual Machine Solution
The Virtual Machine (VM) contains multiple programs. The role is to execute programs passed as parameters, generating processes. It checks that each process calls the "live" instruction every CYCLE_TO_DIE cycle. If after NBR_LIVE executions of the instuction live, several processes are still alive, CYCLE_TO_DIE is decreased by the CYCLE_DELTA units. This starts over until there are no live processes left.

#### REG_NUMBER registers of REG_SIZE byte search</br>
REG_NUMBER and REG_SIZE are defined in the op.h. A register is a memory zone that contains one value. In a real machine, it is embedded within the processor.

#### A C(Counter) </br>
This register contains the memory address in the VM of the next instruction to be coded and executed. 

#### Carry Flag</br>
It's value is '1' only if the last operation returned zero

#### Output </br>
Each program has a number that is generated by the VM and given to the programs in the r1 register at the machine startup. With the execution of the "live" instruction, the machine mus display "The program NBR_OF_PROGRAM (NAME_OF_PROGRAM) is alive." When the player wins, the machine must display "The player NBR_OF_PROGRAM(NAME_OF_PROGRAM) is done."

#### Scheduling </br>
The VM emulates a parallel machine. We assume that each instruction executes entirelay at the end of its last cycke and waits for its entire duration. The instructions that start on the same cycle are executed by program number.

#### Machine Code </br>
The machine recognizes the mnemonic and effects.



| MNEMONIC |<div style="width: 30px"></div> |<div style="width: 250px; word-wrap: break-word;">EFFECT</div> |
|----------|:------:|:---------------------|
| 0X01 (live)||Takes 1 parameter: 4 bytes that represent the player's number. Indicates the player is alive. |
0x02 (ld)||Takes 2 parameters: loads the first parameter to the second parameter. Second parameter is a register. Ex: ld 34, r3 loads the REG_SIZE bytes starting from the Counter + 34 % IDX_MOD into r3. |
0x03 (st)||Takes 2 parameters: Stores first parameter (a register) into the second parameter (it can be another register or a number). Ex: st r4, 34 stores r4 at the address of Counter + 34 % IDX_MOD; st r3, r8 copies r3 into r8. |
0x04 (add)||Takes 3 parameters: 3 registers. Add the first to the second, and store the result to the third. Modifies the carry.|
0x05 (sub)||Same as add, but Subtracting. Modifies the carry.|
0x06 (and)||Same as add, and sub, but does a binary operation AND between the first and the second, and storing the result in the third parameter. Modifies the carry.|
0x07 (or)||Same as and, but performing an OR.|
0x08 (xor)||Same as and and or, but performing an XOR.|
0x09 (zjmp)||Takes 1 parameter, that must be an index. Jumps to this index if carry is 1. Else, does nothing, but still consume time. <br>Zjmp %23 -> if carry == 1, Counter + 23 % IDX_MOD to Counter|
0x0a (ldi)||Takes 3 parameters. First two are indexes and the third one is a register Ex: ldi 3, %4, r1 -> reads IND_SIZ bytes from address Counter + 3 % IDX_MOD, add 4 to this value (SumResult). REG_SIZE byte are read from the Counter + SumResult % IDX_MOD and copies to r1.|
0x0b (sti)||Takes 3 parameters. The first one is a register. The other two can either be indexes or registers. Ex: sti r2, %4, %5 -> copies the content for r2 into Counter + (4 + 5) % IDX_MOD.|
0x0c (fork)||Takes 1 parameter, an index. Creates a new program, inheriting states from the parent, and starting execution at COunter + parameter % IDX_MOD|
0x0d (lld)||Same as ld without the %IDX_MOD. Modifies the carry|
0x0e (lldi)||Same as ldi without the %IDX_MOD. Modifies the carry|
0x0f (lfork)||Same as fork without the %IDX_MOD.|
0x10 (aff)||Takes 1 parameter, a register. Displays to stdout the character corresponding to the ASCII code of the content of the register (in base 10). A 256 modulo is applied to this ASCII code.<br>Ex; aff r3 -> outputs '*' if r3 contains 42.|